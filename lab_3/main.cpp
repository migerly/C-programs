#include <iostream>
#include <syncstream>
#include <thread>
#include <barrier>

constexpr int nt = 3; // кількість робочих потоків

// Бар’єр для синхронізації фаз між 3 потоками
std::barrier sync_point{nt};


void f(char x, int i)
{
    // osyncstream гарантує цілісний вивід рядка з потоку
    std::osyncstream out(std::cout);
    out << "З набору " << x << " виконано дію " << i << ".\n";
}


void worker(int id)
{
    // ----------------- ФАЗА 1: a, d -----------------
    // Розподіл дій (разом 9 = 3 * 3, по 3 на кожен потік):
    //
    // a = 4:  T0: 2 дії, T1: 1 дія, T2: 1 дія
    // d = 5:  T0: 1 дія, T1: 2 дії, T2: 2 дії

    if (id == 0) {
        f('a', 1);
        f('a', 2);
        f('d', 1);
    } else if (id == 1) {
        f('a', 3);
        f('d', 2);
        f('d', 3);
    } else { // id == 2
        f('a', 4);
        f('d', 4);
        f('d', 5);
    }

    sync_point.arrive_and_wait(); // чекаємо завершення фази 1

    // ----------------- ФАЗА 2: b, c, e, f -----------------
    // Загалом 26 дій, ділимо приблизно як 9 / 9 / 8
    //
    // b = 6: T0: 1,2   T1: 3,4   T2: 5,6   (2/2/2)
    // c = 4: T0: 1     T1: 2     T2: 3,4   (1/1/2)
    // e = 8: T0: 1,2,3 T1: 4,5,6 T2: 7,8   (3/3/2)
    // f = 8: T0: 1,2,3 T1: 4,5,6 T2: 7,8   (3/3/2)

    if (id == 0) {
        // b
        f('b', 1);
        f('b', 2);
        // c
        f('c', 1);
        // e
        f('e', 1);
        f('e', 2);
        f('e', 3);
        // f
        f('f', 1);
        f('f', 2);
        f('f', 3);
    } else if (id == 1) {
        // b
        f('b', 3);
        f('b', 4);
        // c
        f('c', 2);
        // e
        f('e', 4);
        f('e', 5);
        f('e', 6);
        // f
        f('f', 4);
        f('f', 5);
        f('f', 6);
    } else { // id == 2
        // b
        f('b', 5);
        f('b', 6);
        // c
        f('c', 3);
        f('c', 4);
        // e
        f('e', 7);
        f('e', 8);
        // f
        f('f', 7);
        f('f', 8);
    }

    sync_point.arrive_and_wait(); // чекаємо завершення фази 2

    // ----------------- ФАЗА 3: i, g, h -----------------
    // Виходимо з вузлів N3 (b,e) і N4 (c,f)
    // Загалом 16 дій, приблизно 6 / 5 / 5
    //
    // i = 4: T0: 1,2   T1: 3      T2: 4        (2/1/1)
    // g = 5: T0: 1,2   T1: 3,4    T2: 5        (2/2/1)
    // h = 7: T0: 1,2   T1: 3,4    T2: 5,6,7    (2/2/3)

    if (id == 0) {
        // i
        f('i', 1);
        f('i', 2);
        // g
        f('g', 1);
        f('g', 2);
        // h
        f('h', 1);
        f('h', 2);
    } else if (id == 1) {
        // i
        f('i', 3);
        // g
        f('g', 3);
        f('g', 4);
        // h
        f('h', 3);
        f('h', 4);
    } else { // id == 2
        // i
        f('i', 4);
        // g
        f('g', 5);
        // h
        f('h', 5);
        f('h', 6);
        f('h', 7);
    }

    sync_point.arrive_and_wait(); // чекаємо завершення фази 3

    // ----------------- ФАЗА 4: j, k -----------------
    // Вихідні ребра з вузлів, де зійшлися i,h та g
    // Разом 13 дій, приблизно 5 / 4 / 4
    //
    // j = 5: T0: 1,2   T1: 3      T2: 4,5     (2/1/2)
    // k = 8: T0: 1,2,3 T1: 4,5,6  T2: 7,8     (3/3/2)

    if (id == 0) {
        // j
        f('j', 1);
        f('j', 2);
        // k
        f('k', 1);
        f('k', 2);
        f('k', 3);
    } else if (id == 1) {
        // j
        f('j', 3);
        // k
        f('k', 4);
        f('k', 5);
        f('k', 6);
    } else { // id == 2
        // j
        f('j', 4);
        f('j', 5);
        // k
        f('k', 7);
        f('k', 8);
    }

}


int main()
{
    setlocale(LC_ALL, "Ukr");

    {
        std::osyncstream out(std::cout);
        out << "Calculate start.\n";
    }

    // Стартуємо рівно nt=3 робочих потоки
    std::thread t0(worker, 0);
    std::thread t1(worker, 1);
    std::thread t2(worker, 2);

    // Чекаємо їх завершення
    t0.join();
    t1.join();
    t2.join();

    {
        std::osyncstream out(std::cout);
        out << "Calculate end.\n";
    }

    return 0;
}
